<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
  xmlns:context="http://www.springframework.org/schema/context"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans-4.0.xsd  
http://www.springframework.org/schema/context
http://www.springframework.org/schema/context/spring-context-4.0.xsd">
	<!-- <context:annotation-config/> -->
	<context:component-scan base-package="com.xiajiajia.dao" />
	<bean id="filePath" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[

C:\x\a.java

]]></value>
		</constructor-arg>
	</bean>

<bean id="beanBuilder" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[
 <import>
 public   class <IBuilder> {
     private  <Iclasstest>  <IclasstestLowerCase>;
     public <IBuilder>(){
           <IclasstestLowerCase> = new <Iclasstest>();
      }
     <IFieldsAll>
     
    <IBuilderMethod>
 
    public <Iclasstest>  build() {
		return <IclasstestLowerCase>;
	}
 }
]]></value>
		</constructor-arg>
</bean>

<bean id="builderMethod" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[
      public <IBuilder> with<IFieldUpperCase>(<IField>  <IFieldLowerCase>) {
		<IclasstestLowerCase>.set<IFieldUpperCase> ( <IFieldLowerCase>);
		return this;
	}
]]></value>
		</constructor-arg>
</bean>


	<bean id="unitTestTemplate" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[
<import>
import static com.markit.markitclear.util.test.ServiceUtil.THROW_EXCEPTION;
import org.junit.Test;
import org.junit.Rule;
import com.markit.markitclear.uiserver.JdbcUniqueIdGenerator;
import org.junit.After;
import org.junit.Before;
import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.runner.RunWith;
import static org.mockito.Matchers.any;
import static org.mockito.Matchers.isA;
import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.reset;
import static org.mockito.Mockito.when;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.fail;
import org.mockito.runners.MockitoJUnitRunner;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
@RunWith(MockitoJUnitRunner.class)
public class <Iclasstest> {
    @Rule
    public CatchExceptionRule rule = new CatchExceptionRule();
    
  <if(isComposer)>
    private static <Icontext>  executionContext;
    private <Irequest> request;
    <IFields>
    @Mock
    private JdbcUniqueIdGenerator                 idGen;
    @InjectMocks
    private  <Iclass> composer = new <Iclass>();
    @BeforeClass
    public static void onceSetUp() throws Exception {
         executionContext = new <Icontext>();
    }
    @Before
    public void setUp() throws Exception {
        request = new <Irequest>();
        when(idGen.uniqueId(JdbcUniqueIdGenerator.DTODATA)).thenReturn(IDGEN_NUMBER);
    }
    
    @After
    public void tearDown() {
    }
    @AfterClass
    public  static void onceTearDown() {
        ServiceUtil.cleanObject(executionContext);
    }
     
    @ExceptionCatch(message = "", value = xxxx.class)
    @Test
    public void shouldReturnRequestIsNull() {
            composer.compose(null, executionContext);
    }
     @ExceptionCatch(message = "", value = xxxx.class)
     @Test
    public void shouldReturnExecutionContextIsNull() {
            composer.compose(request, null);
    } 
  <else>
    <IFields>
    @InjectMocks
    private <Iclass> validator = new <Iclass>();;
    private  <Irequest> request;
    private static ActionTemplateExecutionContext executionContext;
    @BeforeClass
    public static void beforeClassSetup() throws Exception {
         executionContext = new ActionTemplateExecutionContext();
    }
    @Before
    public void beforeSetup() throws Exception {
    request = new <Irequest>();
    }
    
    @After
    public void afterSetup() {
    }
    @AfterClass
    public  static void afterClassSetup() {
        ServiceUtil.cleanObject(executionContext);
    }
  <endif>
      <if(IvalidatorTestMethod)> 
        <IvalidatorTestMethod>
        @Test 
     public void validatorSuccess(){
        ActionResponse ar = validator.validate(request, executionContext);
        assertFalse(ar.hasErrors());  
    }
      <endif>
    <if(isComposer)>
     @Test
    public void composer(){
       <IrequestType> getResult =  composer.compose(request, executionContext) ; 
        assertNotNull(getResult);
        assertEquals("#", "");
    }
    <endif>
}
			]]></value>
		</constructor-arg>
	</bean>
	<bean id="justTest" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[

]]></value>
		</constructor-arg>
	</bean>

	<bean id="validatorMethod" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[
     @Test
    public void <methodName>() {
        // <comment>
        ActionResponse ar = validator.validate(request, executionContext);
        assertErrors(ar, "#");
    }
			]]></value>
		</constructor-arg>
	</bean>

	<bean id="validatorMethodWithException" class="java.lang.String">
		<constructor-arg>
			<value><![CDATA[
    @ExceptionCatch(message = "", value = xxxx.class)
	@Test		
    public void <methodName>() {
        // <comment>
        validator.validate(request, executionContext);
    }
			]]></value>
		</constructor-arg>
	</bean>

</beans>